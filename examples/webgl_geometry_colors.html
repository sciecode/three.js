<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - vertex colors</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				background-color: #fff;
				color: #444;
			}
			a {
				color: #08f;
			}
		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info"><a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - vertex colors</div>

		<script type="module">

			// Simple three.js example

			import * as THREE from "../build/three.module.js";
			import { OrbitControls } from "https://threejs.org/examples/jsm/controls/OrbitControls.js";

			var mesh, renderer, scene, camera, controls, geometry;
			var curT, prevT, curP, prevP, pos, sphere;

			const dt = 0.0016;
			const PI2 = Math.PI / 2;
			const l = 5;

			const pmouse =  new THREE.Vector3();
			const mouse = new THREE.Vector3();
			const F = new THREE.Vector3();
			/* const tmp = new THREE.Vector3(); */

			const Fdamp = new THREE.Vector3();
			const Tdamp = new THREE.Vector3();

			const p = new THREE.Vector3();
			const w = new THREE.Vector3();

			const tp = new THREE.Vector3();
			const tw = new THREE.Vector3();
			const tr = new THREE.Vector3();

			const v1 = new THREE.Vector3();
			const a1 = new THREE.Vector3();
			const v2 = new THREE.Vector3();
			const a2 = new THREE.Vector3();
			const v3 = new THREE.Vector3();
			const a3 = new THREE.Vector3();
			const v4 = new THREE.Vector3();
			const a4 = new THREE.Vector3();

			const qt = new THREE.Quaternion();
			const m4 = new THREE.Matrix4();
			const m3 = new THREE.Matrix3();

			let dr;

			let vs = `

				attribute float displacement;

				uniform sampler2D tpos;

				vec4 getQuaternion( vec3 to ) {

					vec4 q;
					vec3 from = vec3( 0.0, 1.0, 0.0 );

					q.xyz = cross( from, to );
					q.w = dot( from, to ) + 1.0;

					return normalize( q );

				}

				void main() {

					vec3 pos;

					if ( displacement > 0.5 ) {

						vec3 to = texture2D( tpos, vec2( 0.5, 0.5 ) ).xyz;
						vec4 q = getQuaternion( to );
						pos = position + 2.0 * cross( q.xyz, cross( q.xyz, position ) + q.w * position );

					} else {

						pos = position;

					}

					gl_Position = projectionMatrix * viewMatrix * vec4( pos, 1.0 );

				}

			`

			let fs = `

				void main() {

					gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );

				}

			`

			let copy_vert = `
				precision highp float;
				attribute vec2 position;
				void main() {
					gl_Position = vec4( position, vec2(1.0) );
				}
			`;

			let copy_frag = `
				precision highp float;
				uniform vec2 resolution;
				uniform sampler2D texture;
				void main() {
					vec2 uv = gl_FragCoord.xy / resolution.xy;
					gl_FragColor = texture2D( texture, uv );
				}
			`;

			function init() {

				// renderer
				renderer = new THREE.WebGL1Renderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setPixelRatio( window.devicePixelRatio );
				document.body.appendChild( renderer.domElement );

				// scene
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x9c9c9c );

				// camera
				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 0, 10, 20 );
				camera.lookAt( new THREE.Vector3() );

				// lights
				const al = new THREE.AmbientLight( 0xffffff, 0.4 );
				scene.add( al );

				const dl = new THREE.DirectionalLight( 0xf4c3a2, 0.5 );
				dl.position.set( 50, 100, 10 );
				scene.add( dl );

				pos = new Float32Array( 6 );
				var disp = new Float32Array( 2 );

				disp[ 1 ] = 1;

				pos[ 0 ] = 0.0;
				pos[ 1 ] = 0.0;
				pos[ 2 ] = 0.0;
				pos[ 3 ] = 0.0;
				pos[ 4 ] = 5.0;
				pos[ 5 ] = 0.0;

				geometry = new THREE.BufferGeometry();
				geometry.setAttribute( 'position', new THREE.BufferAttribute( pos, 3 ) );
				geometry.setAttribute( 'displacement', new THREE.BufferAttribute( disp, 1 ) );


				// copy

				var data = new Float32Array( 4 );
				data[ 0 ] = Math.sqrt( 3 ) / 2;
				data[ 1 ] = 1 / 2;
				dr = new THREE.DataTexture( data, 1, 1, THREE.RGBAFormat, THREE.FloatType );
				const rtt = new THREE.WebGLRenderTarget( 1, 1, { format: THREE.RGBAFormat, type: THREE.FloatType } );

				var copyShader = new THREE.RawShaderMaterial( {
					uniforms: {
						resolution: { type: 'v2', value: new THREE.Vector2( 1, 1 ) },
						texture: { type: 't' },
						fog: false,
						lights: false,
						depthWrite: false,
						depthTest: false
					},
					vertexShader: copy_vert,
					fragmentShader: copy_frag,
				} );

				const geo = new THREE.BufferGeometry();
				const vertices = new Float32Array( [
					-1.0, -1.0,
					3.0, -1.0,
					-1.0, 3.0
				] );

				geo.setAttribute( 'position', new THREE.BufferAttribute(vertices, 2) );

				mesh = new THREE.Mesh( geo, copyShader );
				mesh.frustumCulled = false;
				copyShader.uniforms.texture.value = dr;
				renderer.setRenderTarget( rtt );
				renderer.render( mesh, new THREE.Camera() );
				renderer.setRenderTarget( null );

				// end copy

				var material = new THREE.ShaderMaterial( {
					uniforms: {
						tpos: { value: rtt.texture }
					},
					vertexShader: vs,
					fragmentShader: fs
				} );

				var line = new THREE.LineSegments( geometry, material );
				scene.add( line );

				window.addEventListener( 'mousemove', onMouseMove );
				renderer.domElement.addEventListener( 'mouseenter', onMouseEnter );

			}

			function onMouseMove( e ) {

				pmouse.copy( mouse );
				mouse.set( e.clientX, 0, e.clientY );

			}

			function onMouseEnter( e ) {

				mouse.set( e.clientX, 0, e.clientY );
				pmouse.copy( mouse );

			}

			function G( q, av, v, w_d ) {

				Tdamp.copy( av ).multiplyScalar( - 30 ); // viscous damping torque

				tr.crossVectors( q, F ).multiplyScalar( l * 20 ); // external torque

				w_d.crossVectors( q, camera.up ).multiplyScalar( 3000 ).add( tr ).add( Tdamp ); // angular acceleration

				v.crossVectors( av, q ); // velocity

			}

			// integration step Runge-Kutta 4th order
			function RK4() {

				F.subVectors( mouse, pmouse );
				pmouse.copy( mouse );

				G( p, w, v1, a1 );
				tp.copy( p ).addScaledVector( v1, 0.5 * dt );
				tw.copy( w ).addScaledVector( a1, 0.5 * dt );
				G( tp, tw, v2, a2 );
				tp.copy( p ).addScaledVector( v2, 0.5 * dt );
				tw.copy( w ).addScaledVector( a2, 0.5 * dt );
				G( tp, tw, v3, a3 );
				tp.copy( p ).addScaledVector( v3, dt );
				tw.copy( w ).addScaledVector( a3, dt );
				G( tp, tw, v4, a4 );

				tp.set( 0, 0, 0 );
				tp.add( v1 );
				tp.addScaledVector( v2, 2 );
				tp.addScaledVector( v3, 2 );
				tp.add( v4 );
				tp.multiplyScalar( dt / 6 );
				p.add( tp );

				tw.set( 0, 0, 0 );
				tw.add( a1 );
				tw.addScaledVector( a2, 2 );
				tw.addScaledVector( a3, 2 );
				tw.add( a4 );
				tw.multiplyScalar( dt / 6 );
				w.add( tw );

			}

			function updateParticles() {

				RK4();

				setPos();

			}

			function animate() {

				// const raf = requestAnimationFrame( animate );

				// updateParticles();

				renderer.render( scene, camera );

			}

			init();
			animate();


		</script>

	</body>
</html>
